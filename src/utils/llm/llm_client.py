
import sys
import os
import asyncio
import httpx
import tiktoken  # Used to calculate token count (ensure installation: `pip install tiktoken`)

# Add path
sys.path.append(os.path.dirname(os.path.realpath(__file__)) + "/..")
from llm.prompt_builder import *

class llm_client:
    def __init__(self, base_url=None, openai_api_keys=None, model='gpt-3.5-turbo-0125'):
        """
        Initialize LLM client
        :param base_url: Base URL of the API
        :param api_keys: List containing multiple API Keys
        :param model: Model name to use, gpt-4o,gpt-4o-mini,gpt-4o-mini-2024-07-18,gpt-3.5-turbo-0125,gpt-4o-2024-11-20
        """
        self.base_url = base_url
        # If api_keys is not provided, use a default API Key
        if not isinstance(openai_api_keys, list):
            openai_api_keys = [openai_api_keys]
        elif len(openai_api_keys) == 0:
            raise ValueError("API Keys list cannot be empty")
        self.api_keys = openai_api_keys
        self.model = model  # Model name
        self.api_key_index = 0  # Used to track the currently used API Key

    def switch_api_key(self):
        """
        Switch to the next API Key. If reaching the end of the list, loop from the beginning.
        """
        self.api_key_index = (self.api_key_index + 1) % len(self.api_keys)
        print(f"Switched to new API Key: {self.api_keys[self.api_key_index]}")

    async def response(self, question):
        """
        Send request to API and return response.
        :param question: Question asked by user
        :return: Response content generated by the model
        """
        url = f"{self.base_url}/chat/completions"
        retries = 100  # Set maximum retry count

        # Step 1: Calculate token count of `question` and check if it exceeds threshold
        encoder = tiktoken.encoding_for_model(self.model)
        tokens = encoder.encode(question)
        
        max_token_threshold = 50000
        if len(tokens) > max_token_threshold:
            print(f"⚠️ Input token count exceeds threshold ({max_token_threshold}), will truncate content...")
            # Truncate tokens to threshold length and decode to string
            truncated_tokens = tokens[:max_token_threshold]
            question = encoder.decode(truncated_tokens)
            # print(f"Truncated `question` is: {question}")
            
        for attempt in range(retries):
            current_api_key = self.api_keys[self.api_key_index]
            headers = {
                "Authorization": f"Bearer {current_api_key}",
                "Content-Type": "application/json",
            }
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "user",
                        "content": question
                    }
                ],
                "temperature": 0.2,
                # "temperature": 0.7,
                "max_tokens": 16000,
                # "max_tokens": 4096,
                "top_p": 1,
                "frequency_penalty": 0,
                "presence_penalty": 0,
                "n": 1
            }

            try:
                async with httpx.AsyncClient(timeout=httpx.Timeout(180.0)) as client:
                    response = await client.post(url, headers=headers, json=payload)
                    response.raise_for_status()  # Raise exception if status code is not 2xx
                    result = response.json()
                    return result["choices"][0]["message"]["content"]  # Return result

            except httpx.ConnectTimeout:
                print(f"Attempt {attempt + 1}: Connection timeout, retrying...")
                self.switch_api_key()  # Switch to next API Key
            except httpx.ReadTimeout:
                print(f"Attempt {attempt + 1}: Read timeout, retrying...")
                self.switch_api_key()  # Switch to next API Key
            except httpx.ConnectError as exc:
                print(f"Attempt {attempt + 1}: Connection error {exc}, retrying...")
                self.switch_api_key()  # Switch to next API Key
            except httpx.HTTPStatusError as exc:
                if exc.response.status_code == 403:
                    print(f"Attempt {attempt + 1}: Insufficient permissions (403 Forbidden), API Key may be invalid or lack access rights, switching API Key and retrying...")
                    self.switch_api_key()  # Switch to next API Key
                elif exc.response.status_code == 429:
                    retry_after = exc.response.headers.get("Retry-After")
                    wait_time = int(retry_after) if retry_after is not None else 5  # Default wait time (5 seconds)
                    print(f"Attempt {attempt + 1}: Request rate too high (429 Too Many Requests), waiting {wait_time} seconds before retry...")
                    await asyncio.sleep(wait_time)  # Wait specified time before retry
                elif exc.response.status_code == 400:
                    error_details = exc.response.json()  # Get detailed error information
                    print(f"Attempt {attempt + 1}: Client request error (400 Bad Request): {error_details}")
                    self.switch_api_key()  # Switch to next API Key
                elif exc.response.status_code == 401:
                    error_details = exc.response.json()  # Get detailed error information
                    print(f"Attempt {attempt + 1}: Authentication failed (401 Unauthorized): {error_details}")
                    print("API Key may be invalid or revoked, trying to switch API Key and retry...")
                    self.switch_api_key()  # Switch to next API Key
                elif exc.response.status_code == 413:  # Handle 413 error
                    print(f"Attempt {attempt + 1}: Request content too large (413 Request Entity Too Large)")
                    self.switch_api_key()  # Switch to next API Key
                    # self.max_tokens = max(self.max_tokens - 2000, 1000)  # Reduce max_tokens but keep minimum value at 1000
                    # print(f"Adjusted max_tokens: {self.max_tokens}")
                elif 500 <= exc.response.status_code < 600:
                    print(f"Attempt {attempt + 1}: Server error {exc.response.status_code}, retrying...")
                    self.switch_api_key()  # Switch to next API Key
                else:
                    print(f"HTTP error: {exc.response.status_code}.")
                    raise
            except Exception as exc:
                print(f"Unknown error: {exc}, retrying...")
                self.switch_api_key()  # Switch to next API Key

            # If maximum retry count is reached, raise exception
            if attempt == retries - 1:
                print(f"Maximum retry count reached ({retries})")
                raise Exception("Request failed: Maximum retry count reached")
